\hypertarget{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff}{}\doxysection{Abstract\+Scope\+Sniff Class Reference}
\label{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff}\index{AbstractScopeSniff@{AbstractScopeSniff}}
Inheritance diagram for Abstract\+Scope\+Sniff\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=11.000000cm]{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_ac7ebcf50db3aca35bd1b1b0f89cee7fc}{\+\_\+\+\_\+construct}} (array \$scope\+Tokens, array \$tokens, \$listen\+Outside=false)
\item 
\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_acc294a6cc8e69743746820e3d15e3f78}{register}} ()
\item 
\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_a145c97f53fb2c1ddb1c188ceba18865f}{process}} (\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_files_1_1_file}{File}} \$phpcs\+File, \$stack\+Ptr)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_a5b158f98e455e906f167070520ff2256}{process\+Token\+Within\+Scope}} (\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_files_1_1_file}{File}} \$phpcs\+File, \$stack\+Ptr, \$curr\+Scope)
\item 
\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_ab6010be3957acc3a6d2c301caa23a950}{process\+Token\+Outside\+Scope}} (\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_files_1_1_file}{File}} \$phpcs\+File, \$stack\+Ptr)
\end{DoxyCompactItemize}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_ac7ebcf50db3aca35bd1b1b0f89cee7fc}\label{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_ac7ebcf50db3aca35bd1b1b0f89cee7fc}} 
\index{AbstractScopeSniff@{AbstractScopeSniff}!\_\_construct@{\_\_construct}}
\index{\_\_construct@{\_\_construct}!AbstractScopeSniff@{AbstractScopeSniff}}
\doxysubsubsection{\texorpdfstring{\_\_construct()}{\_\_construct()}}
{\footnotesize\ttfamily \+\_\+\+\_\+construct (\begin{DoxyParamCaption}\item[{array}]{\$scope\+Tokens,  }\item[{array}]{\$tokens,  }\item[{}]{\$listen\+Outside = {\ttfamily false} }\end{DoxyParamCaption})}

Constructs a new Abstract\+Scope\+Test.


\begin{DoxyParams}[1]{Parameters}
array & {\em \$scope\+Tokens} & The type of scope the test wishes to listen to. \\
\hline
array & {\em \$tokens} & The tokens that the test wishes to listen to within the scope. \\
\hline
boolean & {\em \$listen\+Outside} & If true this test will also alert the extending class when a token is found outside the scope, by calling the process\+Token\+Outside\+Scope method.\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em } & \\
\hline
\end{DoxyExceptions}
\mbox{\hyperlink{namespace_p_h_p___code_sniffer}{PHP\+\_\+\+Code\+Sniffer}}\textbackslash{}\+Exceptions\textbackslash{}\+Runtime\+Exception If the specified tokens arrays are empty or invalid. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_a145c97f53fb2c1ddb1c188ceba18865f}\label{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_a145c97f53fb2c1ddb1c188ceba18865f}} 
\index{AbstractScopeSniff@{AbstractScopeSniff}!process@{process}}
\index{process@{process}!AbstractScopeSniff@{AbstractScopeSniff}}
\doxysubsubsection{\texorpdfstring{process()}{process()}}
{\footnotesize\ttfamily process (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_files_1_1_file}{File}}}]{\$phpcs\+File,  }\item[{}]{\$stack\+Ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [final]}}

Processes the tokens that this test is listening for.


\begin{DoxyParams}[1]{Parameters}
\textbackslash{}\+PHP\+\_\+\+Code\+Sniffer\textbackslash{}\+Files\textbackslash{}\+File & {\em \$phpcs\+File} & The file where this token was found. \\
\hline
int & {\em \$stack\+Ptr} & The position in the stack where this token was found.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void$\vert$int Optionally returns a stack pointer. The sniff will not be called again on the current file until the returned stack pointer is reached. Return (\$phpcs\+File-\/\texorpdfstring{$>$}{>}num\+Tokens + 1) to skip the rest of the file. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_a5b158f98e455e906f167070520ff2256}{process\+Token\+Within\+Scope()}} 
\end{DoxySeeAlso}


Implements \mbox{\hyperlink{interface_p_h_p___code_sniffer_1_1_sniffs_1_1_sniff_a145c97f53fb2c1ddb1c188ceba18865f}{Sniff}}.

\mbox{\Hypertarget{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_ab6010be3957acc3a6d2c301caa23a950}\label{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_ab6010be3957acc3a6d2c301caa23a950}} 
\index{AbstractScopeSniff@{AbstractScopeSniff}!processTokenOutsideScope@{processTokenOutsideScope}}
\index{processTokenOutsideScope@{processTokenOutsideScope}!AbstractScopeSniff@{AbstractScopeSniff}}
\doxysubsubsection{\texorpdfstring{processTokenOutsideScope()}{processTokenOutsideScope()}}
{\footnotesize\ttfamily process\+Token\+Outside\+Scope (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_files_1_1_file}{File}}}]{\$phpcs\+File,  }\item[{}]{\$stack\+Ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [abstract]}, {\ttfamily [protected]}}

Processes a token that is found outside the scope that this test is listening to.


\begin{DoxyParams}[1]{Parameters}
\textbackslash{}\+PHP\+\_\+\+Code\+Sniffer\textbackslash{}\+Files\textbackslash{}\+File & {\em \$phpcs\+File} & The file where this token was found. \\
\hline
int & {\em \$stack\+Ptr} & The position in the stack where this token was found.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void$\vert$int Optionally returns a stack pointer. The sniff will not be called again on the current file until the returned stack pointer is reached. Return (count(\$tokens) + 1) to skip the rest of the file. 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_variable_sniff_ab6010be3957acc3a6d2c301caa23a950}{Abstract\+Variable\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_generic_1_1_sniffs_1_1_naming_conventions_1_1_camel_caps_function_name_sniff_ab6010be3957acc3a6d2c301caa23a950}{Camel\+Caps\+Function\+Name\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_generic_1_1_sniffs_1_1_naming_conventions_1_1_constructor_name_sniff_ab6010be3957acc3a6d2c301caa23a950}{Constructor\+Name\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_my_source_1_1_sniffs_1_1_channels_1_1_include_system_sniff_ab6010be3957acc3a6d2c301caa23a950}{Include\+System\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_p_e_a_r_1_1_sniffs_1_1_naming_conventions_1_1_valid_function_name_sniff_ab6010be3957acc3a6d2c301caa23a950}{Valid\+Function\+Name\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_p_s_r1_1_1_sniffs_1_1_methods_1_1_camel_caps_method_name_sniff_ab6010be3957acc3a6d2c301caa23a950}{Camel\+Caps\+Method\+Name\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_p_s_r2_1_1_sniffs_1_1_methods_1_1_method_declaration_sniff_ab6010be3957acc3a6d2c301caa23a950}{Method\+Declaration\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_squiz_1_1_sniffs_1_1_classes_1_1_self_member_reference_sniff_ab6010be3957acc3a6d2c301caa23a950}{Self\+Member\+Reference\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_squiz_1_1_sniffs_1_1_naming_conventions_1_1_valid_function_name_sniff_ab6010be3957acc3a6d2c301caa23a950}{Valid\+Function\+Name\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_squiz_1_1_sniffs_1_1_scope_1_1_method_scope_sniff_ab6010be3957acc3a6d2c301caa23a950}{Method\+Scope\+Sniff}}, and \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_squiz_1_1_sniffs_1_1_scope_1_1_static_this_usage_sniff_ab6010be3957acc3a6d2c301caa23a950}{Static\+This\+Usage\+Sniff}}.

\mbox{\Hypertarget{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_a5b158f98e455e906f167070520ff2256}\label{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_a5b158f98e455e906f167070520ff2256}} 
\index{AbstractScopeSniff@{AbstractScopeSniff}!processTokenWithinScope@{processTokenWithinScope}}
\index{processTokenWithinScope@{processTokenWithinScope}!AbstractScopeSniff@{AbstractScopeSniff}}
\doxysubsubsection{\texorpdfstring{processTokenWithinScope()}{processTokenWithinScope()}}
{\footnotesize\ttfamily process\+Token\+Within\+Scope (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_files_1_1_file}{File}}}]{\$phpcs\+File,  }\item[{}]{\$stack\+Ptr,  }\item[{}]{\$curr\+Scope }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [abstract]}, {\ttfamily [protected]}}

Processes a token that is found within the scope that this test is listening to.


\begin{DoxyParams}[1]{Parameters}
\textbackslash{}\+PHP\+\_\+\+Code\+Sniffer\textbackslash{}\+Files\textbackslash{}\+File & {\em \$phpcs\+File} & The file where this token was found. \\
\hline
int & {\em \$stack\+Ptr} & The position in the stack where this token was found. \\
\hline
int & {\em \$curr\+Scope} & The position in the tokens array that opened the scope that this test is listening for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void$\vert$int Optionally returns a stack pointer. The sniff will not be called again on the current file until the returned stack pointer is reached. Return (\$phpcs\+File-\/\texorpdfstring{$>$}{>}num\+Tokens + 1) to skip the rest of the file. 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_variable_sniff_a5b158f98e455e906f167070520ff2256}{Abstract\+Variable\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_generic_1_1_sniffs_1_1_naming_conventions_1_1_camel_caps_function_name_sniff_a5b158f98e455e906f167070520ff2256}{Camel\+Caps\+Function\+Name\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_generic_1_1_sniffs_1_1_naming_conventions_1_1_constructor_name_sniff_a5b158f98e455e906f167070520ff2256}{Constructor\+Name\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_my_source_1_1_sniffs_1_1_channels_1_1_include_system_sniff_a5b158f98e455e906f167070520ff2256}{Include\+System\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_p_e_a_r_1_1_sniffs_1_1_naming_conventions_1_1_valid_function_name_sniff_a5b158f98e455e906f167070520ff2256}{Valid\+Function\+Name\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_p_s_r1_1_1_sniffs_1_1_methods_1_1_camel_caps_method_name_sniff_a5b158f98e455e906f167070520ff2256}{Camel\+Caps\+Method\+Name\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_p_s_r2_1_1_sniffs_1_1_methods_1_1_method_declaration_sniff_a5b158f98e455e906f167070520ff2256}{Method\+Declaration\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_squiz_1_1_sniffs_1_1_classes_1_1_self_member_reference_sniff_a5b158f98e455e906f167070520ff2256}{Self\+Member\+Reference\+Sniff}}, \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_squiz_1_1_sniffs_1_1_scope_1_1_method_scope_sniff_a5b158f98e455e906f167070520ff2256}{Method\+Scope\+Sniff}}, and \mbox{\hyperlink{class_p_h_p___code_sniffer_1_1_standards_1_1_squiz_1_1_sniffs_1_1_scope_1_1_static_this_usage_sniff_a5b158f98e455e906f167070520ff2256}{Static\+This\+Usage\+Sniff}}.

\mbox{\Hypertarget{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_acc294a6cc8e69743746820e3d15e3f78}\label{class_p_h_p___code_sniffer_1_1_sniffs_1_1_abstract_scope_sniff_acc294a6cc8e69743746820e3d15e3f78}} 
\index{AbstractScopeSniff@{AbstractScopeSniff}!register@{register}}
\index{register@{register}!AbstractScopeSniff@{AbstractScopeSniff}}
\doxysubsubsection{\texorpdfstring{register()}{register()}}
{\footnotesize\ttfamily register (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [final]}}

The method that is called to register the tokens this test wishes to listen to.

DO NOT OVERRIDE THIS METHOD. Use the constructor of this class to register for the desired tokens and scope.

\begin{DoxyReturn}{Returns}
int\mbox{[}\mbox{]} 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\+\_\+\+\_\+constructor() 
\end{DoxySeeAlso}


Implements \mbox{\hyperlink{interface_p_h_p___code_sniffer_1_1_sniffs_1_1_sniff_acc294a6cc8e69743746820e3d15e3f78}{Sniff}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/workspace/\+Proyecto PHP/project/vendor/squizlabs/php\+\_\+codesniffer/src/\+Sniffs/\mbox{\hyperlink{_abstract_scope_sniff_8php}{Abstract\+Scope\+Sniff.\+php}}\end{DoxyCompactItemize}
